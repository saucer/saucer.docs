---
sidebar_position: 3
---

import code from './custom-types.cpp';
import CodeBlock from '@theme/CodeBlock';

# Interoperability

In the previous chapter, you've created your first saucer application.  
Without explaining what exaclty is being done, I've used a smartview in conjunction with the `Glaze-Serializer` to expose a native function.

I'll now go into more detail on how exactly Interoperability works and will briefly talk about what a Serializer is.

## What is a Serializer

In short, a serializer is something to help us transform our native types into something that both JavaScript and C++ understand.  
Saucer ships the `Glaze-Serializer` by default, however you can also write your own Serializer in case you need something more specific.

## What is a `smartview`

A `smartview` is a type of `webview` that is able to use a serializer to exchange data between C++ and JavaScript.

For more information see:

- [Exposing Functions](#exposing-functions)
- [Calling JavaScript](#calling-javascript)

## Exposing Functions

You can expose a native function to the JavaScript world by calling `expose` on your `smartview`.

```cpp title="Exposing a function"
smartview.expose("add_ten", [](int i)
                            {
                                return i + 10;
                            });

```

By default all exposed functions will be called synchronously, which just means that the `webview` will block until your function is finished, which is usually
not a problem unless your function performs some heavy operations.
You can change this behavior by passing `true` as the last parameter to the `expose` call.

```cpp title="Exposing a function asynchronously"
smartview.expose("add_ten", [](int i)
                            {
                                std::this_thread::sleep_for(std::chrono::seconds(10));
                                return i + 10;
                            // green
                            }, true);

```

Once you've exposed your function from the C++ side, you can easily call it from JavaScript.

```js title="Calling your exposed function from the JavaScript World"
const ten_added = await window.saucer.call('add_ten', [10]);
// > ten_added == 20
```

## Calling JavaScript

Using the `smartview` you'll also be able to evaluate JavaScript code and capture it's result.

```cpp
auto random = smartview.evaluate<float>("Math.random()").get();
```

You can also pass C++ Objects as parameters when calling `eval`.

```cpp
auto random = smartview.evaluate<float>("Math.pow({}, {})", 2, 5).get();
smartview.evaluate<void>("console.log({})", std::vector<int>{10}).get();
```

:::tip
Instead of manually typing out the parameters you can also make use of `saucer::make_args`.

```cpp
auto random = smartview.evaluate<float>("Math.pow({})", saucer::make_args(2, 5)).get();
```

:::

:::caution
`evaluate()` returns a `std::future`, which means that using it outside of an asynchronous context will cause your `webview` to lock up!  
To circumvent this take a look at the [Future Utilities](#future-utilities).
:::

## Future Utilities

Due to the aforementioned problems with using `evaluate` outside of asynchronous contexts, I've created some utility functions to make your life easier.

Start off by including the utility header:

```cpp
#include <saucer/utils/future.hpp>
```

### Then

Because there is no `std::future::then` yet I've implemented a small alternative.

```cpp
saucer::then(smartview.evaluate<float>("Math.random()"), [](float result)
{
    std::cout << "The random number was " << result << std::endl;
});

// ...or

smartview.evaluate<float>("Math.random()") | saucer::then([](float result)
{
    std::cout << "Result: " << result << std::endl;
});
```

### Forget

This can be used to perform a simple fire-and-forget operation.

```cpp
saucer::forget(smartview.evaluate<float>("Math.random()"));

// ...or

smartview.evaluate<float>("Math.random()") | saucer::forget();
```

:::note
A `std::future` will also block on destruction if:

> (2) the shared state is not yet ready[ยน](https://en.cppreference.com/w/cpp/thread/future/%7Efuture)

So make sure you call `saucer::forget` on the future if you don't care about it's return value!

:::

### All

If you have multiple `std::future`s and want to wait until all of them are ready you can use `saucer::all`.

```cpp
auto a = smartview.evaluate<float>("Math.random()");
auto b = smartview.evaluate<float>("Math.random()");
auto c = smartview.evaluate<float>("Math.random()");

auto [random, random2, random3] = saucer::all(a, b, c);
```

## User Defined Types

The `Glaze-Serializer`, which saucer ships by default, supports the serialization of primitives as well as some STL-types by default.  
Please refer to their [documentation](https://github.com/stephenberry/glaze#example) on how to add support for third-party types.

<CodeBlock language="cpp" title="Exposing Custom-Types">
  {code}
</CodeBlock>
