---
sidebar_position: 1
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';
import Admonition from '@theme/Admonition';

# Modules

Modules are an extension to smartviews that can access the native window and webview data used by saucer.  
Thus they're a really powerful tool that can be used to implement completely new features or to alter the current behavior of saucer.

## Native Header

:::tip
If you're using CMake, make sure you have module support enabled!  
This can be achieved by setting `saucer_modules` to `ON`.  
In case you're not using CMake, please refer to your package distributor on how to enable modules.
:::

First, grab the respective native header for your platform.  


<Tabs block>
  <TabItem value="qt" label="Linux">

```cpp
#include <saucer/modules/native/webkitgtk.hpp>
// or
#include <saucer/modules/native/qt.hpp>
```

  </TabItem>
  <TabItem value="windows" label="Windows">

```cpp
#include <saucer/modules/native/webview2.hpp>
```

  </TabItem>
  <TabItem value="macos" label="MacOS">

```cpp
#include <saucer/modules/native/webkit.hpp>
```

  </TabItem>
</Tabs>

## Setup Module

Now I'll setup a basic module by making a class that fullfulls the `saucer::Module` concept.

```cpp title="Example: Basic Module"
class awesome_module
{
    saucer::natives m_natives;
    saucer::smartview_core *m_smartview;

  public:
    awesome_module(saucer::smartview_core *smartview, saucer::natives natives)
        : m_natives(natives), m_smartview(smartview)
    {
    }

    void my_awesome_feature()
    {
        auto [window, webview] = m_natives;

        window->window->setWindowTitle("Hello from Module!");
        webview->web_view->page()->setAudioMuted(true);
    }
};

static_assert(saucer::Module<awesome_module>);
```

:::tip
You can use the compile time macros `SAUCER_QT5`, `SAUCER_QT6`, `SAUCER_WEBKITGTK`, `SAUCER_WEBVIEW2` and `SAUCER_WEBKIT` to find out which backend is currently used.  
:::

## Use Module

To use the module, extend your `smartview` declaration as shown in the following snippet.

```cpp
int main()
{
    auto app = saucer::application::acquire({
        .id = "modules",
    });

    // green-start
    saucer::smartview<saucer::default_serializer, awesome_module> webview{{
        .application = app,
    }};
    // green-end

    webview.set_url("https://github.com/saucer/saucer");
    webview.set_dev_tools(true);

    // green-start
    webview.module<awesome_module>().my_awesome_feature();
    // green-end

    webview.show();
    app->run();

    return 0;
}
```

## Use with Serializer

You might've noticed that our module constructor receives a `smartview_core`.  

This is a stripped down version of the `smartview` you're used to and does not include all the advantages of being coupled with a serializer _(namely, it does not allow seamless interoperability)_.

However, we can modify our module code slightly to also use the fully featured `smartview`.

```cpp title="Example: Module with smartview"
class awesome_module
{
    saucer::natives m_natives;
    saucer::smartview_core *m_smartview;

  public:
    awesome_module(saucer::smartview_core *smartview, saucer::natives natives)
        : m_natives(natives), m_smartview(smartview)
    {
    }

    // green-start
    template <typename Serializer, typename... Modules>
    awesome_module(saucer::smartview<Serializer, Modules...> *smartview, saucer::natives natives)
        : m_natives(natives), m_smartview(smartview)
    {
        smartview->expose("module_add", [](int a, int b) { return a + b; });
    }
    // green-end

    void my_awesome_feature()
    {
        auto [window, webview] = m_natives;

        window->window->setWindowTitle("Hello from Module!");
        webview->web_view->page()->setAudioMuted(true);
    }
};

static_assert(saucer::Module<awesome_module>);
```
